✏️  ☑️ ✍️  ✒️  ✍️ ▶️ 
----------------------------------------------------------------------------
https://www.typescriptlang.org/
https://www.typescriptlang.org/download/

https://youtu.be/lVzb6pmel_E

npm : https://www.npmjs.com/package/ts-node
======================================================================================================
✨ TYPE Script ✨

======================================================================================================
▶️ Install and run
  1]install node js and npm 
  2]fom folder terminal install typescript compiler  ✏️=> npm install -g typescript   ( -g for globle )
-------------------------------------------------------------------- 
  Installation
# Locally in your project.
npm install -D typescript
npm install -D ts-node

# Or globally with TypeScript.
npm install -g typescript
npm install -g ts-node

# Depending on configuration, you may also need these
npm install -D tslib @types/node
--------------------------------------------------------------------
☑️use npx for window's  get typescript version
    tsc --version
npx tsc --version

--------------------------------------------------------------------
create config file  command
	tsc --init
npx tsc --init
--------------------------------------------------------------------
compile typescript file

in terminal type 
npx tsc fileName.ts   			✏️=> for manual compile and run  also create .js file
npx tsc fileName.ts --watch 	✏️=> for Auto compile and run
-------
we can run transconpile js file with node also

node <dir>/fileName.js         ✏️=> for manual transconpile .js file, append folder path if file save in any specific location
ts-node fileName.ts 					 ✏️=> run directly
--------------------------------------------------------------------
To run ts file directly
npm i ts-node -g  (or) npm i -g ts-node  			✏️=> run ts file directly  

ts-node fileName.ts run ts file directly 

======================================================================================================
"use strict";
--------------------------------------------------------------------
forEach
-------

map

-------
reduce

push

pop

typeof

instaaceof

is

as

keyOf

StringArray
--------------------------------------------------------------------
var age : number = 20;
-------
let numArray: number[] = [1, 2, 3, 4];
let charArray: string[] = ['a', ''];
-------
✏️=> object is a type
let obj: object = {
name: 'Abc',
age: 10};

obj = { ... obj, phone: 12333444 };
console.log(obj);

-------
let obj: {name : string,age number} = {
name: 'Abc',
age: 10};

--------------------------------------------------------------------
if (typeof a === "string")
a.toUpperCase();


--------------------------------------------------------------------
// Type Inference
// .Understanding type inference
// ·Type annotations

let a = "12"; ✏️=>Type Inference

let a : number  = "12";  ✏️=>Type Annotations
let a : number |boo|string  = "12"; 
--------------------------------------------------------------------
? => optional
--------------------------------------------------------------------
======================================================================================================

======================================================================================================
## datatype

https://github.com/Nykz/typescript-course-material/blob/main/ts/index.ts

Categories

· Primitive Types => in build datatype
. Object Types
· Special Types
· Advanced Types
. Function Types
----------------------------------
// Basic Types (Primitive types and Referance type)
// .Primitive types (number, string, boolean)
// .Arrays
// .Tuples
// .Enums
// .Any, Unknown, Void, Null, Undefined, Never
----------------------------------
Primitive Types

· number
· string
. boolean
· null

· undefined
· bigint
· symbol
----------------------------------
Referance type
[],{},()

Object Type

· Array
· Tuple
. Object (key:value)pair
----------------------------------
Special Types

· any
· unknown
· void
· never  (

----------------------------------
Advanced Types

· Union

. Intersection
· Type Alias
· Enum
. Literal Types
----------------------------------
Function Types

Defines the type of a function.
----------------------------------
let a: string | null;    ✏️=> accept string or null
a = "harsh";
a = null;
----------------------------------
// let a1: number = 1;
// a1 = 10;

// function add1(a: number, b: number): number {
//     return a + b; // type checking
// }

// const y = add1(1, a1);
// console.log(y);

// a1 = y;
// console.log(a1);
------------------------------------------------------------------------------------------------------
### Basic types datatype

let num: number = 1234_564_5646;
let num1: bigint = 12344354355464566456636666456345655436n;
console.log('num: ', num);
console.log('num1: ', num1);
----------------------------------
let character: string = 'Code with Technyks';
let isAvailable: boolean = true;
----------------------------------
let val: null = null;

----------------------------------
### undefined

// let user;
// console.log(user); // undefined
----------------------------------
### object 
let obj: { name: string, age: number } = {
    name: 'Abc', 
    age: 10
};

obj = { ...obj, age: 44, name: 'abc1' };
console.log(obj);
----------------------------------
### any type
let numVal: any;
numVal = 1;
numVal = 'a';

function testAnyType(val: any) {
    console.log(val);
}
----------------------------------
### Arrays
let numArray: number[] = [1, 2, 3, 4];
let charArray: string[] = ['a', 'b'];
// charArray.forEach(val => val.includes('a'));
// numArray.forEach(val => val.toFixed(2));
----------------------------------
### tuples

let arr: [number, string] = [1, 'Alice'];

let coordinates3D: [number, number, number] = [10, 20, 30]; // (x, y, z) axis

// localhost:4200?name=Technyks&phone=1234567890
let userData: [string, number] = ['Technyks', 1234567890];

let response: [number, string] = [200, "Success"]; // http-response
//response.push(0); // drawback of tuple in ts
// console.log('response: ', response);
----------------------------------

### enum

// PascalCase
enum Color {
    // APP_NAME = 'my_app_name',
    Red = 'red',
    Green = 'green',
    Blue = 'blue'
}

console.log(Color.Blue);

let color: Color = Color.Green;
console.log(color);
------------
// const Small = 1;
// const Medium = 2;
// const Large = 3;

// let size = Medium;

// enum Size {
//     Small = 1,
//     Medium,
//     Large
// }

const enum Size {
    Small = 1,
    Medium,
    Large
}

let size: Size = Size.Large;
console.log('size: ', size);
----------------------------------
###  unknown type

let notSure: unknown = 'a';

if(typeof(notSure) === 'number') {
    notSure.toFixed(2);
} else if(typeof(notSure) === 'string') {
    notSure.length;
}
----------------------------------
###  never type

function infiniteLoop(): never {
    while(true) {
        // do something endlessly
        console.log(1);
    }
}

function throwError(message: string): never {
    throw new Error(message);
}

// throwError('Something weng wrong');
----------------------------------
###  void type

function logMessage(message: string): void {
    console.log(message);
    // return undefined;
}

----------------------------------
###  type inference
let username = 'Nikhil'; // typescript infers the type as string

// type assertions
let someValue: any = 'Hello world';
let strLength: number = (someValue as string).length;   ✏️=> assertions with as keyword
console.log(strLength);



let a = "12"; ✏️=>Type Inference

let a : number  = "12";  ✏️=>Type Annotations or assertions
----------------------------------
###  union types

let id: string | number; // id can either be string or a number
id = 'abc';
id = 101;
// id = true;

function printId(id: string | number) {
    console.log(`id: ${ id }`); // 'id: ' + id
}

printId('abc');
printId(101);
----------------------------------
###  type narrowing     //✏️=>to detect specific type from union type
function printIdFn(id: string | number) {
    if(typeof id === 'string') {
        console.log('id is a string: ', id.toUpperCase());
    } else {
        console.log(`id is a number: ${ id }`); // 'id: ' + id
    }
}
// printIdFn('xyz');
printIdFn(1);

----------------------------------
###  interface

interface Person44 {
    name: string;
    age: number;
    greet(): void
    // greet: () => void
}

// function greet() {
//     console.log('Hi');
// }

let person: Person44 = {
    name: 'abc',
    age: 10,
    greet() {
        console.log('Hi');
    },
    // greet
};

person.greet();
----------------------------------
// interface with Function types
interface MathOp {
    (a: number, b: number): number;
}

const add: MathOp = (x, y) => x + y;
const subtract: MathOp = (x, y) => x - y;

console.log('add 2 numbers: ', add(1, 2));
console.log('subtract 2 numbers: ', subtract(5, 4));
----------------------------------
## type alias  (use type keyword)

// type AliasName = TypeDefinition; // syntax
type UserID = string;

let userId: UserID = 'abc';
-----------
type Person1 = {
    name: string;
    age: number;
};

let person1: Person1 = {
    name: 'abc',
    age: 12
}

console.log(person1.name);
-----------
type ID = string | number;

let userId1: ID = 'abc';
let orderId: ID = 101;
----------------------------------
// interface vs type alias
interface User {
    name: string;
    phone?: number;
}
   
//✏️=>  mearging type or extend other tyme  using extends we can same with type aliase  usning intrsection "&"
// interface Customer extends User {
//     address: string;
// }

// let myCustomer: Customer = {
//     name: 'X',
//     phone: 122314345,
//     address: 'abc',
// };

interface User {
    address: string;
}

let myCustomer: User = {
    name: 'X',
    // phone: 122314345,
    address: 'abc',
};


type Vehicle = {
    make: string;
    model?: string;
};
----------------------------------
// & -> intersection types (append two types)
type Car = Vehicle & {
    isElectric?: boolean;
};

let myCar: Car = {
    make: 'TATA',
    // model: 'TATA PUNCH',
    // isElectric: true
};

// type Vehicle = {
//     isElectric: boolean,
// };
// error duplicate type identifier

// let myCar: Vehicle = {
//     make: 'TATA',
//     model: 'TATA PUNCH',
//     isElectric: true, // error
// };
----------------------------------
type MathOp1 = (a: number, b: number) => number;
let add1: MathOp1 = (x, y) => x + y;
console.log(add1(2, 2));

type Status = "active" | "inactive" | "pending";

let userStatus: Status = 'active';

type Tree = {
    value: string;
    children?: Tree[];
}

// reccurecive
let tree: Tree = {
    value: 'root',
    children: [
        {
            value: 'child1',
            // children: [{ value: 'grandChild', children: [] }]
        }
    ]
}
----------------------------------
## intersection types
let config: { server: string; port: number } & { secure: boolean; timeout: number } = {
    server: 'localhost',
    port: 8080,
    secure: true,
    timeout: 5000
};
----------------------------------
// .Intersection types

interface User {
name: string;
email: string;
password: string;
}

interface Admin extends User {
admin: boolean;

}

function abcd(obj: Admin){
obj.admin
}
----------------------------------

----------------------------------


======================================================================================================
### Function
https://github.com/Nykz/typescript-course-material/blob/main/ts/functions.ts

function abcd( a : string ,b : number ): void {
console. log ("hey");

--------------------------------------------------------------------
// Regular functions

function addNumbers(a: number, b: number): number {
    return a + b;
}

console.log(addNumbers(2, 6));

// function expression
const divide = function (a: number, b: number): number {
    return a / b;
};

console.log(divide(8, 2));

// arrow functions
const multiply = (a: number, b: number): number => {
    return a * b;
};
const multiply1 = (a: number, b: number): number => a * b;

console.log(multiply(4, 2));

// optional parameters
function greet(username: string, greeting?: string): string {
    // return greeting + ' ' + username;
    // return `${greeting ? greeting : ''} ${username}`; // ternary operator
    return greeting ? `${greeting} ${username}` : `${username}`; // ternary operator
}

console.log(greet('Nikhil'));


// default parameters
function greet1(username: string, greeting: string = 'Hi'): string {
    // return greeting + ' ' + username;
    return `${greeting} ${username}`; // ternary operator
}

console.log('Greet1: ', greet1('Nikhil', 'Hey'));

// function overloading
function getLength1(value: string): number;
function getLength1(value: any[]): number;
function getLength1(value: any): number {
    return value.length;
}

console.log(getLength1('hello'));
console.log(getLength1([1, 2, 3]));

// Rest parameters
function sum(...numbers: number[]): number {
    // return numbers.reduce((total, num) => {
    //     return total + num;
    // }, 0);    //=>✏️ zero is initial value of total
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4));
console.log(sum(5, 7, 3, 4, 10, 100));

function greet12(greeting: string, ...names: string[]): void {
    names.forEach((name) => {
        console.log(`${greeting}, ${name}`);
    });
}

greet12('Hello', 'Nikhil', 'Code with Technyks', 'Everyone');
----------------------------------

--------------------------------------------------------------------


======================================================================================================


======================================================================================================
### generics
https://github.com/Nykz/typescript-course-material/blob/main/ts/generics.ts

/* generics
 Generics are a way to create components (functions, classes or interfaces)
 that work with different types without losing type safety
*/

// generic function
function genericIdentity<T>(arg: T): T {
    return arg;
}

console.log(genericIdentity<number>(10));
console.log(genericIdentity<string>('Hi'));
console.log(genericIdentity<boolean>(true));

// generic interface
interface KeyPair<T, U> {
    key: T;
    value: U;
}

let keyPairValue: KeyPair<string, number> = {
    key: 'pair',
    value: 10
};

// generic constraints
function getLength<T extends { length: number }>(item: T): number {
    return item.length;
}

console.log(getLength('Hello'));
console.log(getLength([1, 2, 3]));
// console.log(getLength(123));

// generic classes
class Box<T> {
    contents: T;

    constructor(value: T) {
        this.contents = value;
    }

    getContents(): T {
        return this.contents;
    }
}

const numberBox = new Box(100);
console.log(numberBox.getContents());

const stringBox = new Box('Hello');
console.log(stringBox.getContents());


class Stack<T> {
    private items: T[] = [];

    push(item: T): void {
        this.items.push(item);
    }

    pop(): T | undefined {
        return this.items.pop();
    }

    getStack(): T[] {
        return this.items;
    }
}

const numberStack = new Stack<number>();
numberStack.push(10);
numberStack.push(20);
console.log(numberStack.getStack());
console.log(numberStack.pop());
console.log(numberStack.getStack());

const stringStack = new Stack<string>();
stringStack.push('Hi');
stringStack.push('There');
console.log(stringStack.getStack());
console.log(stringStack.pop());
console.log(stringStack.getStack());
======================================================================================================
###  literal_types literal types
// literal types


// string literal
type OrderStatus = 'delivered' | 'pending' | 'cancelled';
let order: OrderStatus = "pending";

let answer: 'yes' | 'no';
answer = 'no';

// number literal
let count: 0 | 1 | 2;
count = 0;

// boolean literal
let isVisible: true | false;
isVisible = true;

type LiteralType = 'hello' | 2 | 'hi' | { name: string; age: number };

type Action = 'add' | 'update' | 'delete';

function takeAction(action: Action) {
    switch(action) {
        case 'add': 
            console.log('add function');
            break;
        case 'update':
            console.log('update function');
            break;
        case 'delete': 
            console.log('delete function');
            break;
        default: 
            console.log('none');
            break;
    }
}

function printStatus(status: 'success' | 'error' | 'loading'): void {
    console.log(`Current state is ${status}`);
}

printStatus('success');
// printStatus('completed');


interface ButtonConfig {
    size: 'small' | 'medium' | 'large';
    color: 'red' | 'green' | 'blue';
}

const btn: ButtonConfig = {
    size: 'medium',
    color: 'green',
};

======================================================================================================
### type_guard type guard (type narrowing)

// type guards
// typeof
// instanceof
// custom type guard fn

function printID(id: string | number) {
    if(typeof id === 'string') {
        console.log(`id is a string: ${id}`);
    } else {
        console.log(`id is a number: ${id}`);
    }
}

class Dog1 {
    bark() {
        console.log('Woof!');
    }
}

class Cat1 {
    meow() {
        console.log('Meow!');
    }
}

function handlePet(pet: Dog1 | Cat1) {
    if(pet instanceof Dog1) {
        pet.bark();
    } else {
        pet.meow();
    }
}

interface Fish {
    swim(): void;
}

interface Bird {
    fly(): void;
}

function isFish(pet: Fish | Bird): pet is Fish {
    return (pet as Fish).swim !== undefined;
}

function move(pet: Fish | Bird) {
    if(isFish(pet)) {
        pet.swim();
    } else {
        pet.fly();
    }
}


function isString(value: any): value is string {
    return typeof value === 'string';
}

function checkType(value: string | number) {
    if(isString(value)) {
        console.log('value is string');
    } else {
        console.log('value is number');
    }
}

checkType(10);
//

// keyof operator
interface Person12 {
    name: string;
    age: number;
    email: string;
}

type PersonKeys = keyof Person12;
let keys: PersonKeys = 'name';


======================================================================================================
### class  and object classes

class Person {
    name: string;
    age: number;

    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }

    greet(): string {
        return `Hello, my name is ${this.name}, and I'm ${this.age} yrs old`;
    }
}

const new_person = new Person('Diya', 19);
console.log(new_person.greet());
console.log(new_person.name);

/* 
access modifiers (public, private, protected)

public: Accessible from anywhere. This is the default if no modifier is specified.
private: Accessible only within the class.
protected: Accessible within the class and its subclasses.
*/

class Car1 {
    public make: string;
    private model: string;
    protected year: number;

    constructor(make: string, model: string, year: number) {
        this.make = make;
        this.model = model;
        this.year = year;
    }

    public getModel(): string {
        return this.model;
    }
}

const newCar = new Car1('Tesla', 'Model 10', 2024);
console.log(newCar.getModel());
// console.log(newCar.model);

// inheritance

class Animal { // parent class
    
    constructor(
        public name: string
    ) {}

    makeSound(): void {
        console.log('Some generic sound...');
    }
}

class Dog extends Animal { // child class

    constructor(name: string) {
        super(name);
    }

    // makeSound(): void {
    //     console.log('Woof! Woof!');
    // }

}

const dog = new Dog('Puppy');
dog.makeSound();

// Abstract class

abstract class Shape {
    abstract getArea(): number; // abstract method, must be implemented bt subclasses

    printArea(): void {
        console.log(`The area is ${this.getArea()}`);
    }
}

class Rectangle extends Shape {

    constructor(private width: number, private height: number) {
        super();
    }

    getArea(): number {
        return this.width * this.height;
    }

}

const rect = new Rectangle(5, 10);
rect.printArea();

// setters & getters

class Circle {
    private _radius: number;
    strlength: number | undefined;

    constructor(radius: number) {
        this._radius = radius;
    }

    get radius(): number {
        return this._radius;
    }

    set radius(value: number) {
        if(value <= 0) {
            throw new Error('Radius must be positive');
        }
        this._radius = value;
    }
}

const circle = new Circle(10);
console.log(circle.radius);
circle.radius = 12;
console.log(circle.radius);
// circle.radius = -5;
// console.log(circle.radius);
circle.strlength = 2;
console.log(circle!.strlength); // Non-null assertion

======================================================================================================
### index_signature index signature
// index signature
/*
An index signature in TypeScript is used to define types for objects 
that can have properties of dynamic keys, where the keys are not 
known in advance but you still want to enforce the type of the values. 
Index signatures are particularly useful when working with objects 
that act like dictionaries or maps.
*/

interface StringArray {
    [index: number]: string;
}

let array1: StringArray = ['Code', 'with', 'Technyks'];
console.log(array1[2]);

interface Fruit {
    [key: string]: string;
}

const fruitsArray: Fruit = {
    apple: 'A fruit',
    banana: 'A yellow fruit',
};

console.log(fruitsArray["banana"]);
======================================================================================================

======================================================================================================

======================================================================================================

======================================================================================================

======================================================================================================

======================================================================================================
